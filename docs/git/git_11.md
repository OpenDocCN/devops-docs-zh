# git-rm

> 原文： [`git-scm.com/docs/git-rm`](https://git-scm.com/docs/git-rm)

## 名称

git-rm - 从工作树和索引中删除文件

## 概要

```
git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] <file>…​
```

## 描述

从索引中删除文件，或从工作树和索引中删除文件。 `git rm`不会仅从您的工作目录中删除文件。 （没有选项能只将文件从工作树中删除而还在索引中保留;如果非要这样做，请使用`/bin/rm`。）要删除的文件必须与分支的尖端相同，并且虽然可以使用`-f`选项覆盖默认行为，但不能在索引中暂存对其内容的更新。当给出`--cached`时，分阶段内容必须匹配分支的尖端或磁盘上的文件，从而允许仅从索引中删除文件。

## 选项

```
 <file>…​ 
```

要删除的文件。可以给出 Fileglobs（例如`*.c`）以删除所有匹配的文件。如果你想让 Git 扩展文件 glob 字符，你可能需要 shell 转义它们。可以给出一个前置目录名称（例如，删除`dir/file1`和`dir/file2`的`dir`）以删除目录中的所有文件，并递归地删除所有子目录，但这需要明确给出`-r`选项。

```
 -f 
```

```
 --force 
```

覆盖最新的检查。

```
 -n 
```

```
 --dry-run 
```

实际上不要删除任何文件。相反，只显示它们是否存在于索引中，否则将被命令删除。

```
 -r 
```

在给出前导目录名时允许递归删除。

```
 -- 
```

此选项可用于将命令行选项与文件列表分开（当文件名可能被误认为是命令行选项时很有用）。

```
 --cached 
```

使用此选项仅从索引中取消暂存和删除路径。无论是否修改了工作树文件，都将保持不变。

```
 --ignore-unmatch 
```

即使没有匹配的文件，也以零状态退出。

```
 -q 
```

```
 --quiet 
```

`git rm`通常为每个删除的文件输出一行（以`rm`命令的形式）。此选项会禁止输出。

## 讨论

<file>给予命令的列表可以是精确的路径名，文件 glob 模式或前置目录名。该命令仅删除 Git 已知的路径。已知文件路径，但没有告诉 Git 的文件不会被删除。

文件通配符跨目录边界匹配。因此，给定两个目录`d`和`d2`，使用`git rm 'd*'`和`git rm 'd/*'`之间存在差异，因为前者也将删除所有目录`d2`。

## 删除已从文件系统中消失的文件

`git rm`没有选项只从索引中删除从文件系统中消失的路径。但是，根据用例，有几种方法可以完成。

### 使用“git commit -a”

如果您打算下一次提交应记录工作树中跟踪文件的所有修改，并记录已使用`rm`（而不是`git rm`）从工作树中删除的文件的所有删除，请使用`git commit -a`，因为它会自动注意并记录所有删除。通过使用`git add -u`，您也可以在不提交的情况下获得类似的效果。

### 使用“git add -A”

当接受供应商分支的新代码丢弃时，您可能希望记录路径的删除和新路径的添加以及现有路径的修改。

通常，您将首先使用以下命令从工作树中删除所有跟踪的文件：

```
git ls-files -z | xargs -0 rm -f
```

然后解压缩工作树中的新代码。或者你可以 _rsync_ 对工作树进行更改。

之后，记录工作树中所有删除，添加和修改的最简单方法是：

```
git add -A
```

见 [git-add [1]](https://git-scm.com/docs/git-add) 。

### 其他方法

如果您真正想要做的就是从索引中删除工作树中不再存在的文件（可能是因为您的工作树是脏的，因此您无法使用`git commit -a`），请使用以下命令：

```
git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached
```

## 子模块

只有使用 gitfile 的子模块（这意味着它们用 Git 1.7.8 或更新版本克隆）将从工作树中删除，因为它们的存储库位于超级项目的.git 目录中。如果子模块（或其中嵌套的子模块之一）仍然使用.git 目录，`git rm`会将子模块 git 目录移动到 superprojects git 目录中以保护子模块的历史记录。如果在[gitmodules [5]](https://git-scm.com/docs/gitmodules)中存在 submodule.<name>部分，那么文件将被删除，并被暂存（除非使用了--cached 或-n）。

当 HEAD 与索引中记录的相同时，子模块被认为是最新的，未修改跟踪文件，并且子模块工作树中不存在未被忽略的未跟踪文件。忽略的文件被认为是可消耗的，并且不会阻止子模块的工作树被删除。

如果您只想从工作树中删除子模块的本地签出而不提交删除，请改用 [git-submodule [1]](https://git-scm.com/docs/git-submodule) `deinit`。有关子模块移除的详细信息，请参见 [gitsubmodules [7]](https://git-scm.com/docs/gitsubmodules) 。

## 例子

```
 git rm Documentation/\*.txt 
```

从索引中的`Documentation`目录及其任何子目录中删除所有`*.txt`文件。

请注意，在此示例中，引用了星号`*`;这让 Git 而不是 shell 扩展了`Documentation/`目录下的文件和子目录的路径名。

```
 git rm -f git-*.sh 
```

因为此示例允许 shell 展开星号（即您明确列出文件），所以它不会删除`subdir/git-foo.sh`。

## BUGS

每次超级项目更新删除填充的子模块时（例如，在删除之前和之后切换提交时），旧的子模块检出将保留在旧位置。删除旧目录只有在使用 gitfile 时才是安全的，否则子模块的历史记录也将被删除。当实现递归子模块更新时，此步骤将过时。

## 也可以看看

[git-add [1]](https://git-scm.com/docs/git-add)

## GIT

部分 [git [1]](https://git-scm.com/docs/git) 套件